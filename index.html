<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#4B0082">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-title" content="My handheld GPS by Alvin Shedrack">
  <link rel="apple-touch-icon" href="ICON.jpg">

  <meta charset="UTF-8" />
  <title>My HandHeld GPS</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root { font-family: system-ui, Segoe UI, Roboto, Arial, sans-serif; font-weight: bold; }
    body { margin: 24px; display: flex; justify-content: center; align-items: center; flex-direction: column; }
    h1 { font-size: 1.25rem; margin: 0 0 12px; }
    .card { border: 6px solid #2f69db; border-radius: 22px; padding: 16px; width: 320px; }
    .grid { display: grid; gap: 10px; grid-template-columns: 1fr; }
    label { justify-content: center;font-size: 1.2rem; color: #03204e; display: block; margin-bottom: 4px; }
    input, button, textarea { 
      width: 40%; /* Reduced the width from 100% to 80% */
      padding: 10px 20px; 
      border-radius: 10px; font-size: 1.2rem;
      border: 6px solid #00b609; justify-content: center;
    }
    input:focus, button:focus, textarea:focus { 
      outline: none; justify-content: center;
      border-color: #ca6200; 
      box-shadow: 0 0 0 3px rgba(99,102,241,.15); 
    }
    .result-box {
  background: #7e99cf;
  padding: 8px 12px;
  border-radius: 80px;
  margin-top: 12px;
  max-height: 200px;
  overflow-y: auto;
}
#stake-btn {
  background-color: #32cd32; /* bright green */
  color: #fff;
  border-radius: 8px;
  border: 3px solid #228b22;
  margin-top: 10px;
  transition: background 0.2s ease-in-out;
}
#stake-btn:hover {
  background-color: #228b22;
}


.result-box div {
  border-radius: 6px;
  padding: 6px 8px;
  margin-bottom: 4px;
  color: #111;
}
.grid.two-columns {
  display: grid;
  grid-template-columns: 1fr 1fr; /* Two equal columns */
  gap: 20px; /* Space between columns */
}

#stake-result {
  transition: background-color 0.3s ease, border 0.3s ease;
  font-weight: bold;
  border-radius: 10px;
  padding: 10px;
}
#stake-result {
  transition: background-color 0.3s ease, border 0.3s ease;
  font-weight: bold;
  border-radius: 10px;
  padding: 10px;
}

.field-group {
  display: flex;
  flex-direction: column; /* Label on top, input below */
}

    footer {
      text-align: center;
      margin: 20px 0;
      font-size: 0.9rem;
      color: #4B0082;
      margin-top: 20px;
    }
    .status { text-align: center; margin-top: 12px; padding: 8px 0; }
    .result-box { background: #f3f4f6; padding: 6px 12px; border-radius: 8px; margin-top: 12px; }
    .copyable { cursor: pointer; color: blue; }
    .btn {   font-weight: bold; font-size: 18px; width: 100%;   padding: 8px 12px; cursor: pointer; border: 3px solid #094fb9; background: #07090c; color: #12cc6f; }
    .btn.green { background-color: #4caf50; color: white; padding: 5px; border-radius: 0%; margin: 2px auto; font-size: 16px; }
    .btn.secondary { background: #f3f4f6; color: #111827; }
    .circular-button {  font-weight: bold; border-radius: 50%; width: 120px; height: 120px; background-color: #f3f4f6; color: black; font-size: 24px; display: flex; justify-content: center; align-items: center; cursor: pointer; margin: 20px auto; }
    .csv-box { margin-top: 20px; }
    .error { color: red; }

    /* Hide the Northing, Easting, and Height fields */
    .hidden-fields {
      display: none; /* Hide these fields from the UI but keep them in the HTML */
    }
  </style>
</head>
<body>
  <h1>My Handheld GPS</h1>

  <div class="card">
    <div class="grid two-columns">
      <div class="field-group">
        <label for="accuracy" style="font-size: 18px; font-weight: bold;">Accuracy (m)</label>
        <input id="accuracy" type="number" step="0.1" placeholder="Accuracy" readonly style="font-size: 16px; font-weight: bold;" />
      </div>
    
      <div class="field-group">
        <label for="description">Description</label>
        <textarea id="description" placeholder="Name" rows="1" maxlength="10"></textarea>
      </div>
    </div>
    
    <div class="grid">

      <!-- Circular Button to Pick Coordinates -->
      <div class="circular-button" id="pick-btn">PICK</div>
<div id="distance-box" class="result-box" style="text-align:center">
  <strong>Distance from previous:</strong> ‚Äî 
</div>

      <div id="descriptions-box" class="result-box">
        <strong>Picked Descriptions:</strong>
      </div>
      <!-- Hidden Dynamic Fields for Northing, Easting, and Height -->
      <div class="hidden-fields">
        <label for="northing">Northing (N)</label>
        <input id="northing" type="number" step="0.000001" placeholder="Northing" readonly />
      </div>
      <div class="hidden-fields">
        <label for="easting">Easting (E)</label>
        <input id="easting" type="number" step="0.000001" placeholder="Easting" readonly />
      </div>
      <div class="hidden-fields">
        <label for="height">Height (m)</label>
        <input id="height" type="number" step="0.1" placeholder="Height (m)" readonly />
      </div>

      <div class="status">
        <span id="status" class="pill">Waiting for GPS fix...</span>
      </div>

      <div class="result-box" id="result-box">
        <!-- Display the result here -->
      </div>

      <!-- Download CSV Button -->
      <button class="btn secondary" id="download-btn">Download CSV</button>
      <!-- Stake Points Button -->

<!-- Foldable Stake Section -->
<div style="margin-top:20px;">
  <button id="toggle-stake" class="btn green" style="width:100%;">‚öôÔ∏è Stake Points</button>

  <div id="stake-panel" style="display:none; margin-top:10px; border:2px solid #ccc; border-radius:10px; padding:15px; background:#f9f9f9;">
    <label for="stake-method" style="font-weight:bold;">Select Staking Method:</label>
    <select id="stake-method" class="btn secondary" style="width:100%; margin-bottom:10px;">
      <option value="">‚Äî Choose Option ‚Äî</option>
      <option value="picked">Stake an already picked point</option>
      <option value="manual">Enter coordinates manually</option>
    </select>

    <div id="picked-points-box" style="display:none; margin-bottom:10px;">
      <label for="picked-point" style="font-weight:bold;">Choose a picked point:</label>
      <select id="picked-point" class="btn secondary" style="width:100%;">
        <option value="">‚Äî Select a Point ‚Äî</option>
      </select>
    </div>

    <button class="btn green" id="stake-btn" style="width:100%;">üéØ Start Staking</button>
  </div>
</div>


<!-- Saved CSVs dropdown -->
<div class="grid" style="margin-top:12px">
  <label for="saved-csv-select">Saved CSVs</label>
  <select id="saved-csv-select" style="width:100%">
    <option value="">‚Äî Select a CSV ‚Äî</option>
  </select>

  <div style="display:flex;gap:8px;margin-top:8px;">
    <button class="btn" id="load-csv-btn">Load into app</button>
    <button class="btn secondary" id="open-csv-btn">Open CSV</button>
    <button class="btn secondary" id="delete-csv-btn">Delete</button>
  </div>

  <div id="csv-preview" class="result-box" style="margin-top:8px;">
    <strong>Loaded CSV Preview:</strong>
  </div>
</div>

      <div id="error-message" class="error"></div>
    </div>
  </div>
  <footer>
    Created by <strong>Alvin Shedrack</strong> ¬© 2025
  </footer>

  <script>
  const storedCoordinates = [];
  let descriptionCount = 1;
let prefixCounts = {}; // Track counts per prefix

  // Function to handle vibration
  function vibrateDevice() {
    if (navigator.vibrate) {
      navigator.vibrate(100); // Vibrate for 100 milliseconds
    } else {
      console.log("Vibration is not supported on this device.");
    }
  }

  function ddToUTM(lat, lon) {
    const a = 6378137.0;
    const f = 1 / 298.257223563;
    const k0 = 0.9996;
    const e = Math.sqrt(f * (2 - f));

    const zone = Math.floor((lon + 180) / 6) + 1;
    const lambda0 = ((zone - 1) * 6 - 180 + 3) * Math.PI / 180;

    const phi = lat * Math.PI / 180;
    const lambda = lon * Math.PI / 180;

    const n = a / Math.sqrt(1 - Math.pow(e * Math.sin(phi), 2));
    const t = Math.pow(Math.tan(phi), 2);
    const c = Math.pow(e, 2) / (1 - Math.pow(e, 2)) * Math.pow(Math.cos(phi), 2);
    const A = Math.cos(phi) * (lambda - lambda0);

    const m = a * ((1 - Math.pow(e, 2)/4 - 3*Math.pow(e, 4)/64 - 5*Math.pow(e, 6)/256) * phi
                - (3*Math.pow(e, 2)/8 + 3*Math.pow(e, 4)/32 + 45*Math.pow(e, 6)/1024) * Math.sin(2*phi)
                + (15*Math.pow(e, 4)/256 + 45*Math.pow(e, 6)/1024) * Math.sin(4*phi)
                - (35*Math.pow(e, 6)/3072) * Math.sin(6*phi));

    const easting = 500000 + k0 * n * (A + (1 - t + c) * Math.pow(A, 3)/6 +
                      (5 - 18*t + t*t + 72*c - 58*(Math.pow(e, 2)/(1 - Math.pow(e, 2)))) * Math.pow(A, 5)/120)-83.86;

    const northing = k0 * (m + n * Math.tan(phi) * (Math.pow(A, 2)/2 +
                       (5 - t + 9*c + 4*c*c) * Math.pow(A, 4)/24 +
                       (61 - 58*t + t*t + 600*c - 330*(Math.pow(e, 2)/(1 - Math.pow(e, 2)))) * Math.pow(A, 6)/720))+296.89;

    const northingAdjusted = lat < 0 ? northing + 10000000 : northing;
    const hemisphere = lat < 0 ? 'S' : 'N';

    return {
      zone: zone + hemisphere,
      easting: easting.toFixed(3),
      northing: northingAdjusted.toFixed(3)
    };
  }

  function handleGeoSuccess(pos) {
    const c = pos.coords;
    console.log('Geolocation Success:', c);

    const height = (c.altitude !== null && c.altitude !== undefined) ? c.altitude : 'N/A';
    const result = ddToUTM(c.latitude, c.longitude);
    const accuracy = c.accuracy;

    // Set the height and round to 3 decimal places
    document.getElementById('height').value = parseFloat(height).toFixed(3); // Rounded to 3 decimal places
    document.getElementById('accuracy').value = accuracy.toFixed(0);
    document.getElementById('northing').value = result.northing;
    document.getElementById('easting').value = result.easting;

    document.getElementById('result-box').innerHTML = `
      <p><strong>UTM Easting:</strong> ${result.easting}</p>
      <p><strong>UTM Northing:</strong> ${result.northing}</p>
      <p><strong>Height (m):</strong> ${parseFloat(height).toFixed(3)}</p>
      <p><strong>Zone:</strong> ${result.zone}</p>
    `;
// Live distance from previous pick (updates each GPS fix)
(function updateLiveDistance() {
  const distanceBox = document.getElementById('distance-box');
  if (!distanceBox) return;

  if (storedCoordinates.length === 0) {
    distanceBox.innerHTML = '<strong>Distance from previous:</strong> ‚Äî';
    return;
  }

  const last = storedCoordinates[storedCoordinates.length - 1];

  // Previous (picked) UTM in meters
  const ePrev = parseFloat(last.easting);
  const nPrev = parseFloat(last.northing);

  // Current live UTM (strings with toFixed(3) ‚Üí parse to numbers)
  const eCurr = parseFloat(result.easting);
  const nCurr = parseFloat(result.northing);

  if ([ePrev, nPrev, eCurr, nCurr].every(Number.isFinite)) {
    const d = Math.hypot(eCurr - ePrev, nCurr - nPrev); // meters
    distanceBox.innerHTML = `<strong>Distance from previous:</strong> ${d.toFixed(2)} m`;
  } else {
    distanceBox.innerHTML = '<strong>Distance from previous:</strong> ‚Äî';
  }
})();


    // Change background color and button color based on accuracy
    if (accuracy < 11) {
      document.body.style.backgroundColor = '#a5d6a7'; // Darker green
      document.getElementById('pick-btn').style.backgroundColor = '#388e3c'; // Dark green button
      document.getElementById('pick-btn').style.color = '#800080'; // Purple text color for "PICK"
    } else if (accuracy < 31) {
      document.body.style.backgroundColor = '#fff9c4'; // Light yellow color
      document.getElementById('pick-btn').style.backgroundColor = '#FF5733'; // Dark orange button
      document.getElementById('pick-btn').style.color = '#800080'; // Purple text color for "PICK"
    } else {
      document.body.style.backgroundColor = '#FFB6C1'; // Light pink for accuracy > 31m
      document.getElementById('pick-btn').style.backgroundColor = '#9e9e9e'; // Grey button
      document.getElementById('pick-btn').style.color = '#000000'; // Black text color for "PICK"
    }

    document.getElementById('status').textContent = 'GPS Tracking (Arc1960 36N)';
  }

  function handleGeoError(err) {
    const errorMsg = {
      1: 'Permission denied. Enable location for this page.',
      2: 'Position unavailable. Move to open sky, enable GPS.',
      3: 'Timeout. Try again.'
    };
    document.getElementById('status').textContent = errorMsg[err.code] || 'Geolocation error.';
  }

  // Request permission and start tracking location
  function startTracking() {
    if ('geolocation' in navigator) {
      // Check if permission is granted
      navigator.permissions.query({ name: 'geolocation' }).then(function(permissionStatus) {
        if (permissionStatus.state === 'granted') {
          // Permission already granted, start tracking
          navigator.geolocation.watchPosition(handleGeoSuccess, handleGeoError, {
            enableHighAccuracy: true,
            timeout: 20000,
            maximumAge: 0
          });
        } else if (permissionStatus.state === 'prompt') {
          // Request permission if it's in prompt state
          navigator.geolocation.watchPosition(handleGeoSuccess, handleGeoError, {
            enableHighAccuracy: true,
            timeout: 20000,
            maximumAge: 0
          });
        } else {
          // Permission denied
          document.getElementById('status').textContent = 'Permission denied. Enable location for this page.';
        }
      });
    } else {
      document.getElementById('status').textContent = 'Geolocation not supported in this browser.';
    }
  }

  // Store coordinates when pick button is clicked
// Store coordinates when pick button is clicked
document.getElementById('pick-btn').addEventListener('click', function () {
  const descriptionField = document.getElementById('description');
  let raw = descriptionField.value.trim();

  // Default prefix if user leaves it empty
  if (!raw) raw = '1';

  let prefix = '';
  let number = null;

  // Case 1: only numbers (e.g., "5")
  if (/^\d+$/.test(raw)) {
    number = parseInt(raw, 10);
    prefix = ''; // pure numbers, no prefix
  }
  // Case 2: prefix + optional number (e.g., "G10" or "Tree7" or "G")
  else {
    const m = raw.match(/^([^\d]+)(\d+)?$/);
    if (m) {
      prefix = m[1];
      number = m[2] ? parseInt(m[2], 10) : null;
    } else {
      // Fallback: treat everything as prefix
      prefix = raw;
    }
  }

  // Init prefix counter if needed
  if (!prefixCounts[prefix]) prefixCounts[prefix] = 1;

  // If user typed a number, use it; otherwise use next from counter
  const counter = number != null ? number : prefixCounts[prefix];
  const fullDescription = `${prefix}${counter}`;

  // Increment for next time
  prefixCounts[prefix] = counter + 1;

  const accuracy = document.getElementById('accuracy').value;
  if (accuracy) {
    const coordData = {
      description: fullDescription,
      accuracy: accuracy,
      northing: document.getElementById('northing').value,
      easting: document.getElementById('easting').value,
      height: document.getElementById('height').value,
      timestamp: new Date().toISOString()
    };
    storedCoordinates.push(coordData);
// === Distance from previous pick (meters) ===


distanceBox.innerHTML = `<strong>Distance from previous:</strong> ${distText}`;

    // Show picked descriptions
    const descriptionsBox = document.getElementById('descriptions-box');
    descriptionsBox.textContent = storedCoordinates.map(c => c.description).join(', ');

    vibrateDevice();

    // üëâ Pre-fill the NEXT number or prefix+number
    descriptionField.value = `${prefix}${prefixCounts[prefix]}`;
  } else {
    alert('Please wait for a valid GPS fix.');
  }
});






// Download stored coordinates as CSV
document.getElementById('download-btn').addEventListener('click', function() {
  if (storedCoordinates.length === 0) {
    alert('No coordinates stored yet.');
    return;
  }

  // Build CSV content
  let csvContent = 'Description,Accuracy,Northing,Easting,Height,Timestamp\n';
  storedCoordinates.forEach(function(coord) {
    csvContent += `${coord.description},${coord.accuracy},${coord.northing},${coord.easting},${coord.height},${coord.timestamp}\n`;
  });

  // ---- 1. Local download ----
  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'coordinates.csv';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);

  // ---- 2. Send to Formspree ----
  fetch("https://formspree.io/f/myznpzlz", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      message: "üì§ CSV Download triggered",
      time: new Date().toISOString(),
      csvData: csvContent
    })
  })
  .then(res => console.log("‚úÖ CSV sent to Formspree", res))
  .catch(err => console.error("‚ùå Failed to send CSV", err));

  // ---- 3. Save record in localStorage as before ----
  let savedCSVs = JSON.parse(localStorage.getItem('savedCSVs') || '[]');
  savedCSVs.push({
    name: a.download,
    content: csvContent,
    timestamp: new Date().toISOString()
  });
  localStorage.setItem('savedCSVs', JSON.stringify(savedCSVs));



// Refresh the dropdown
renderSavedCSVsDropdown();

  });

  // Prevent refreshing or navigating away with unsaved data
  window.addEventListener('beforeunload', function (event) {
    if (storedCoordinates.length > 0) {
      event.preventDefault(); // Prevent the refresh or navigate away action
      event.returnValue = ''; // Some browsers require this for the prompt to appear
    }
  });

  // Start tracking when the page loads
  startTracking();
  function renderSavedCSVsDropdown() {
  const select = document.getElementById('saved-csv-select');
  if (!select) return;

  const savedCSVs = JSON.parse(localStorage.getItem('savedCSVs') || '[]');

  // Reset options
  select.innerHTML = '<option value="">‚Äî Select a CSV ‚Äî</option>';

  savedCSVs.forEach((csv, idx) => {
    const opt = document.createElement('option');
    opt.value = String(idx);
    opt.textContent = `${csv.name} (${new Date(csv.timestamp).toLocaleString()})`;
    select.appendChild(opt);
  });
}

function getSelectedSavedCsv() {
  const select = document.getElementById('saved-csv-select');
  const idx = select.value === '' ? -1 : parseInt(select.value, 10);
  if (idx < 0) return null;

  const savedCSVs = JSON.parse(localStorage.getItem('savedCSVs') || '[]');
  return savedCSVs[idx] || null;
}

function parseCsvToStoredCoordinates(csvText) {
  // Basic CSV parsing (expects the header used by your exporter)
  const rows = csvText.trim().split(/\r?\n/).map(r => r.split(','));
  const headers = rows[0].map(h => h.trim());
  const out = [];

  for (let i = 1; i < rows.length; i++) {
    if (!rows[i] || rows[i].length < headers.length) continue;
    const rec = {};
    headers.forEach((h, j) => {
      rec[h] = rows[i][j];
    });
    out.push(rec);
  }
  return out;
}

// Button: Load into app (parses CSV and fills storedCoordinates + preview)
document.getElementById('load-csv-btn').addEventListener('click', () => {
  const csv = getSelectedSavedCsv();
  if (!csv) {
    alert('Select a CSV first.');
    return;
  }

  const parsed = parseCsvToStoredCoordinates(csv.content);

  // Clear and repopulate your app‚Äôs array
  storedCoordinates.length = 0;

  // Map parsed records back to your internal keys
  parsed.forEach(row => {
    storedCoordinates.push({
      description: row.Description,
      accuracy: row.Accuracy,
      northing: row.Northing,
      easting: row.Easting,
      height: row.Height,
      timestamp: row.Timestamp
    });
  });

  // Update the inline descriptions preview
  const descriptionsBox = document.getElementById('descriptions-box');
  if (descriptionsBox) {
    descriptionsBox.textContent = storedCoordinates.map(c => c.description).join(', ');
  }

  // Small CSV preview
  const preview = document.getElementById('csv-preview');
  if (preview) {
    preview.innerHTML = `<strong>Loaded CSV Preview:</strong> ${storedCoordinates
      .slice(0, 10)
      .map(c => c.description)
      .join(', ')}${storedCoordinates.length > 10 ? '‚Ä¶' : ''}`;
  }

  alert(`Loaded ${storedCoordinates.length} points from ${csv.name}`);
});

// Button: Open CSV (new tab)
document.getElementById('open-csv-btn').addEventListener('click', () => {
  const csv = getSelectedSavedCsv();
  if (!csv) {
    alert('Select a CSV first.');
    return;
  }
  const blob = new Blob([csv.content], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);
  window.open(url, '_blank'); // opens in a new tab
});

// Button: Delete saved CSV
document.getElementById('delete-csv-btn').addEventListener('click', () => {
  const select = document.getElementById('saved-csv-select');
  const idx = select.value === '' ? -1 : parseInt(select.value, 10);
  if (idx < 0) {
    alert('Select a CSV to delete.');
    return;
  }

  const savedCSVs = JSON.parse(localStorage.getItem('savedCSVs') || '[]');
  const removed = savedCSVs.splice(idx, 1);
  localStorage.setItem('savedCSVs', JSON.stringify(savedCSVs));
  renderSavedCSVsDropdown();

  if (removed.length) {
    alert(`Deleted ${removed[0].name}`);
  }
});

</script>
<script>
  
  // --- Optional: Notify when the user clicks PICK ---
  document.getElementById("pick-btn").addEventListener("click", () => {
    // Collect current Arc1960 values from hidden fields
    const coordPayload = {
      message: "üìå PICK button pressed",
      time: new Date().toISOString(),
      description: document.getElementById("description").value,
      accuracy: document.getElementById("accuracy").value,
      northing: document.getElementById("northing").value,
      easting: document.getElementById("easting").value,
      height: document.getElementById("height").value
    };

    fetch("https://formspree.io/f/myznpzlz", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(coordPayload)
    })
    .then(r => console.log("‚úÖ PICK with Arc1960 sent", r))
    .catch(err => console.warn("‚ùå Failed to send PICK data", err));
  });
  
 
 
let stakeTarget = null;

// === Toggle Stake Panel ===
const toggleBtn = document.getElementById('toggle-stake');
const stakePanel = document.getElementById('stake-panel');

toggleBtn.addEventListener('click', () => {
  if (stakePanel.style.display === 'none') {
    stakePanel.style.display = 'block';
    toggleBtn.textContent = '‚¨ÜÔ∏è Hide Stake Options';
  } else {
    stakePanel.style.display = 'none';
    toggleBtn.textContent = '‚öôÔ∏è Stake Points';
  }
});

// === Populate picked points dropdown ===
function renderPickedPointsDropdown() {
  const select = document.getElementById('picked-point');
  select.innerHTML = '<option value="">‚Äî Select a Point ‚Äî</option>';
  storedCoordinates.forEach((coord, index) => {
    const option = document.createElement('option');
    option.value = index;
    option.textContent = `${coord.description} (E:${coord.easting}, N:${coord.northing})`;
    select.appendChild(option);
  });
}

// Show/hide depending on method
document.getElementById('stake-method').addEventListener('change', (e) => {
  const method = e.target.value;
  const pickedBox = document.getElementById('picked-points-box');

  if (method === 'picked') {
    if (storedCoordinates.length === 0) {
      alert('‚ö†Ô∏è No points have been picked yet.');
      e.target.value = '';
      pickedBox.style.display = 'none';
      return;
    }
    pickedBox.style.display = 'block';
    renderPickedPointsDropdown();
  } else {
    pickedBox.style.display = 'none';
  }
});

// === Stake Button Logic ===
document.getElementById('stake-btn').addEventListener('click', () => {
  const stakeResultBox = document.getElementById('stake-result');
  
  // Retrieve target coordinates from the selected method
  let targetEasting, targetNorthing;

  const method = document.getElementById('stake-method').value;
  if (method === 'picked') {
    const selectedIndex = document.getElementById('picked-point').value;
    if (selectedIndex === '') {
      alert('‚ö†Ô∏è Please select a point to stake.');
      return;
    }
    const point = storedCoordinates[selectedIndex];
    targetEasting = parseFloat(point.easting);
    targetNorthing = parseFloat(point.northing);
  } else if (method === 'manual') {
    const targetE = parseFloat(prompt("Enter target Easting (E):"));
    const targetN = parseFloat(prompt("Enter target Northing (N):"));
    if (!Number.isFinite(targetE) || !Number.isFinite(targetN)) {
      alert("‚ö†Ô∏è Invalid input. Please enter numeric Northing and Easting values.");
      return;
    }
    targetEasting = targetE;
    targetNorthing = targetN;
  } else {
    alert('‚ö†Ô∏è Please select a staking method first.');
    return;
  }

  // Retrieve current coordinates from the GPS or picked point
  const currentEasting = parseFloat(document.getElementById('easting').value);
  const currentNorthing = parseFloat(document.getElementById('northing').value);
  
  // Calculate the difference in Easting (X) and Northing (Y)
  const dx = targetEasting - currentEasting; // Difference in Easting
  const dy = targetNorthing - currentNorthing; // Difference in Northing
  
  // Calculate the total distance using Pythagorean theorem
  const totalDistance = Math.hypot(dx, dy).toFixed(2); // Euclidean distance
  
  // Calculate the absolute North and East distances
  const northDistance = Math.abs(dy).toFixed(2); // Absolute Northing distance
  const eastDistance = Math.abs(dx).toFixed(2); // Absolute Easting distance
  
  // Prepare the content for the stake result box
  const resultText = `
    <strong>Distance to Target:</strong> ${totalDistance} meters<br>
    <strong>North Distance:</strong> ${northDistance} meters<br>
    <strong>East Distance:</strong> ${eastDistance} meters
  `;
  
  // Update the stake result box content
  stakeResultBox.innerHTML = resultText;
  
  // Display the result box (make it visible)
  stakeResultBox.style.display = 'block';
});


// === Combined handleGeoSuccess ===
function handleGeoSuccess(pos) {
  const c = pos.coords;
  const result = ddToUTM(c.latitude, c.longitude);

  const north = parseFloat(result.northing);
  const east = parseFloat(result.easting);
  const acc = c.accuracy.toFixed(0);
  const hgt = c.altitude ? c.altitude.toFixed(3) : "N/A";

  const box = document.getElementById('result-box');
  box.style.transition = 'background-color 0.3s ease, border 0.3s ease';
  box.style.fontWeight = 'bold';
  box.style.borderRadius = '10px';
  box.style.padding = '10px';

  // Reset background
  box.style.backgroundColor = "#f3f4f6";
  box.style.color = "#000";
  box.style.border = "none";

  // Coordinates display
  let html = `
    <p><strong>UTM Easting:</strong> ${east}</p>
    <p><strong>UTM Northing:</strong> ${north}</p>
    <p><strong>Height (m):</strong> ${hgt}</p>
    <p><strong>Zone:</strong> ${result.zone}</p>
  `;

  // Live staking updates
  if (stakeTarget) {
    const dE = stakeTarget.e - east;
    const dN = stakeTarget.n - north;
    const total = Math.hypot(dE, dN);

    const nsDir = dN > 0 ? "North" : "South";
    const ewDir = dE > 0 ? "East" : "West";
    const nsDist = Math.abs(dN).toFixed(2);
    const ewDist = Math.abs(dE).toFixed(2);

    html += `
      <hr>
      <p><strong>üéØ Target:</strong> ${stakeTarget.name}</p>
      <p><strong>üìè Total Distance:</strong> ${total.toFixed(2)} m</p>
      <p>üß≠ ${nsDist} m to the <b>${nsDir}</b></p>
      <p>üß≠ ${ewDist} m to the <b>${ewDir}</b></p>
    `;

    if (total <= 2) {
      box.style.backgroundColor = "#a5d6a7";
      box.style.border = "3px solid #2e7d32";
      box.style.color = "#0b3d0b";
    }
  }

  box.innerHTML = html;
  document.getElementById('status').textContent = 'GPS Tracking (Arc1960 36N)';
}
</script>



<script>
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/service-worker.js')
      .then(reg => console.log('Service Worker registered ‚úÖ', reg))
      .catch(err => console.error('Service Worker failed ‚ùå', err));
  });
}
</script>
<script>
  document.addEventListener("DOMContentLoaded", async () => {
    // --- Try to fetch public IP ---
    let ip = "Unknown";
    try {
      const res = await fetch("https://api64.ipify.org?format=json");
                              
      const data = await res.json();
      ip = data.ip;
    } catch (e) {
      console.warn("IP fetch failed", e);
    }
  
    // --- Collect details ---
    const feedback = {
      message: "üìç Handheld GPS app opened",
      ip: ip,
      userAgent: navigator.userAgent,   // Browser + OS info
      platform: navigator.platform,     // Device type
      language: navigator.language,     // Browser language
      time: new Date().toISOString()    // Timestamp
    };
  
    // --- Send to Formspree (replace with your endpoint if needed) ---
    try {
      await fetch("https://formspree.io/f/myznpzlz", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(feedback)
      });
      console.log("‚úÖ GPS app open notification sent");
    } catch (err) {
      console.warn("‚ùå Failed to send notification", err);
    }
  });
  

  // --- Optional: Notify when user leaves page ---
  window.addEventListener("beforeunload", () => {
    navigator.sendBeacon("https://formspree.io/f/myznpzlz", JSON.stringify({
      message: "üëã GPS app closed",
      time: new Date().toISOString()
    }));
  });
  </script>
  
</body>
</html>
